#lang racket

(struct concat (arg1 arg2) #:transparent)
(struct either (arg1 arg2) #:transparent)
(struct repeat (arg1) #:transparent)

(define exp1 '())
(define exp2 '(a b b a b))
(define exp3 (concat '(a b) (either '(c) '(d))))
(define exp4 (repeat (either '(a) '(b))))
(define exp5 (concat (either '(a) '(the))
                     (concat (either '(mouse) '(cat)) 
                             (either '(ran) '(slept)))))

(define (ok-string? value)
  (and (list? value)
       (andmap symbol? value)))

(define (reg-exp? value)
  (cond
    [(ok-string? value) #t]
    [(concat? value)
     (and (reg-exp? (concat-arg1 value))
          (reg-exp? (concat-arg2 value)))]
    [(either? value)
     (and (reg-exp? (either-arg1 value))
          (reg-exp? (either-arg2 value)))]
    [(repeat? value)
     (reg-exp? (repeat-arg1 value))]
    [else #f]))

(define (flip bias)
  (< (random) bias))

(define (pick lst)
  (if (null? lst)
      #f
      (list-ref lst (random (length lst)))))

(define (generate-string-from-reg-exp exp)
  (cond
    [(ok-string? exp) exp]
    [(concat? exp)
     (append (generate-string-from-reg-exp (concat-arg1 exp))
             (generate-string-from-reg-exp (concat-arg2 exp)))]
    [(either? exp)
     (if (flip 0.5)
         (generate-string-from-reg-exp (either-arg1 exp))
         (generate-string-from-reg-exp (either-arg2 exp)))]
    [(repeat? exp)
     (let ([inner-exp (repeat-arg1 exp)])
       (if (flip 0.5)
           (append (generate-string-from-reg-exp inner-exp)
                   (generate-string-from-reg-exp exp))
           '()))]
    [else '()]))

(define (dfa-accepts? mach str)
  (let loop ([state (dfa-start-state mach)]
             [s str])
    (cond
      [(null? s)
       (if (member state (dfa-accepting-states mach) equal?)
           #t
           #f)]
      [else
       (let* ([symbol (car s)]
              [key (list state symbol)]
              [next-state
               (let find ([ts (dfa-transitions mach)])
                 (cond
                   [(null? ts) #f]
                   [(equal? (entry-key (car ts)) key)
                    (entry-value (car ts))]
                   [else
                    (find (cdr ts))]))])
         (and next-state
              (loop next-state (cdr s))))])))

(define (generate-parse-tree-from-cfg grammar)
  (let ([start-symbol (cfg-start-symbol grammar)])
    (let generate ([nt start-symbol])
      (let ([applicable-rules (filter (lambda (rule)
                                         (equal? (rule-lhs rule) nt))
                                       (cfg-rules grammar))])
        (if (null? applicable-rules)
            (leaf nt)
            (let ([chosen-rule (pick applicable-rules)])
              (if chosen-rule
                  (let ([rhs (rule-rhs chosen-rule)])
                    (node nt
                          (map (lambda (sym)
                                 (if (member sym (cfg-nonterminals grammar))
                                     (generate sym)
                                     (leaf sym)))
                               rhs)))
                  (leaf nt))))))))

(define (generate-string-from-cfg grammar)
  (let extract ([tree (generate-parse-tree-from-cfg grammar)])
    (cond
      [(leaf? tree) (list (leaf-label tree))]
      [(node? tree)
       (apply append
              (map extract
                   (node-children tree)))]
      [else '()])))

(define dfa-mcd
  (dfa "dfa-mcd"
       '(it swam dreamed that)
       'start
       '(saw-vi saw-v3-that-saw-vi)
       (list
        (entry '(start it) 'after-it)
        (entry '(after-it swam) 'saw-vi)
        (entry '(after-it dreamed) 'after-dreamed)
        (entry '(after-dreamed that) 'after-that)
        (entry '(after-that it) 'after-that-it)
        (entry '(after-that-it swam) 'saw-v3-that-saw-vi))))

(define exp-mcd
  (concat '(it)
          (either '(swam)
                  (concat '(dreamed)
                          (concat '(that)
                                  (concat '(it) '(swam)))))))

(define my-cfg
  (cfg '(if then else x y z)
       '(stmt cond action)
       'stmt
       (list
        (rule 'stmt '(if cond then action))
        (rule 'stmt '(if cond then action else action))
        (rule 'stmt '(if cond then stmt))
        (rule 'stmt '(if cond then stmt else action))
        (rule 'stmt '(if cond then action else stmt))
        (rule 'stmt '(if cond then stmt else stmt))
        (rule 'cond '(x))
        (rule 'cond '(y))
        (rule 'cond '(z))
        (rule 'action '(x))
        (rule 'action '(y))
        (rule 'action '(z)))))

; Examples of sentences generated by my-cfg:
; - (if x then y)
; - (if x then y else z)
; - (if x then if y then z)
; - (if x then if y then z else x)
; - (if x then y else if z then x)
; - (if x then if y then z else if x then y)

; TC-201 Simulator Procedures
; Problem 3: diff-configs, incr-pc, do-load, do-store

; Note: This file assumes the following functions exist from Problems 1 and 2:
; - ram-read, ram-write, diff-rams (from Problem 1)
; - extract, bits->int, int->bits, int->bits-width (from Problem 2)
; - entry, entry?, entry-key, entry-value
; - conf, conf?, conf-cpu, conf-ram

; Helper function to get a register value from CPU
(define (get-register cpu reg-name)
  (cond
    [(null? cpu) #f]
    [(eq? (entry-key (car cpu)) reg-name)
     (entry-value (car cpu))]
    [else (get-register (cdr cpu) reg-name)]))

; Helper function to set a register value in CPU
(define (set-register cpu reg-name new-value)
  (map (lambda (e)
         (if (eq? (entry-key e) reg-name)
             (entry (entry-key e) new-value)
             e))
       cpu))

; (diff-configs config1 config2)
; Returns a list of triples showing where configs differ
; Order: CPU registers first (acc, pc, rf, aeb), then memory in increasing address order
(define (diff-configs config1 config2)
  (let ([cpu1 (conf-cpu config1)]
        [cpu2 (conf-cpu config2)]
        [ram1 (conf-ram config1)]
        [ram2 (conf-ram config2)])
    
    ; Helper to collect CPU register differences
    (define (check-cpu-regs reg-name diffs)
      (let ([val1 (get-register cpu1 reg-name)]
            [val2 (get-register cpu2 reg-name)])
        (if (equal? val1 val2)
            diffs
            (cons (list reg-name val1 val2) diffs))))
    
    ; Check CPU registers in order: acc, pc, rf, aeb
    (let ([cpu-diffs (check-cpu-regs 'aeb 
                     (check-cpu-regs 'rf 
                     (check-cpu-regs 'pc 
                     (check-cpu-regs 'acc '()))))])
      
      ; Check memory using diff-rams, then combine
      (let ([ram-diffs (diff-rams ram1 ram2)])
        (append cpu-diffs ram-diffs)))))

; (incr-pc n config)
; Increments the program counter by n (modulo 4096)
(define (incr-pc n config)
  (let* ([cpu (conf-cpu config)]
         [ram (conf-ram config)]
         [pc-bits (get-register cpu 'pc)]
         [pc-value (bits->int pc-bits)]
         [new-pc-value (modulo (+ pc-value n) 4096)]
         [new-pc-bits (int->bits-width new-pc-value 12)]
         [new-cpu (set-register cpu 'pc new-pc-bits)])
    (conf new-cpu ram)))

; (do-load address config)
; Loads memory[address] into accumulator
(define (do-load address config)
  (let* ([cpu (conf-cpu config)]
         [ram (conf-ram config)]
         [mem-value (ram-read address ram)]
         [new-cpu (set-register cpu 'acc mem-value)])
    (conf new-cpu ram)))

; (do-store address config)
; Stores accumulator into memory[address]
(define (do-store address config)
  (let* ([cpu (conf-cpu config)]
         [ram (conf-ram config)]
         [acc-value (get-register cpu 'acc)]
         [new-ram (ram-write address acc-value ram)])
    (conf cpu new-ram)))

; Helper function to convert sign/magnitude bits to integer
(define (sign-mag->int bits)
  (let ([sign (car bits)]
        [magnitude (bits->int (cdr bits))])
    (if (= sign 0)
        magnitude
        (- magnitude))))

; Helper function to convert integer to sign/magnitude bits (16 bits)
(define (int->sign-mag n)
  (cond
    [(= n 0) '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)]  ; +0
    [(> n 0) (cons 0 (int->bits-width n 15))]     ; positive
    [else (cons 1 (int->bits-width (- n) 15))]))   ; negative

; Helper function to check if integer fits in 16-bit sign/magnitude
(define (fits-sign-mag? n)
  (and (>= n -32767) (<= n 32767)))

; (do-add address config)
; Adds memory[address] to accumulator using sign/magnitude arithmetic
(define (do-add address config)
  (let* ([cpu (conf-cpu config)]
         [ram (conf-ram config)]
         [acc-bits (get-register cpu 'acc)]
         [mem-bits (ram-read address ram)]
         [acc-val (sign-mag->int acc-bits)]
         [mem-val (sign-mag->int mem-bits)]
         [result-val (+ acc-val mem-val)])
    (if (fits-sign-mag? result-val)
        ; Result fits - set acc to result, aeb to 0
        (let* ([new-acc-bits (int->sign-mag result-val)]
               [new-cpu (set-register (set-register cpu 'acc new-acc-bits) 'aeb '(0))])
          (conf new-cpu ram))
        ; Overflow - set acc to +0, aeb to 1
        (let* ([new-cpu (set-register (set-register cpu 'acc '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)) 'aeb '(1))])
          (conf new-cpu ram)))))

; (do-sub address config)
; Subtracts memory[address] from accumulator using sign/magnitude arithmetic
(define (do-sub address config)
  (let* ([cpu (conf-cpu config)]
         [ram (conf-ram config)]
         [acc-bits (get-register cpu 'acc)]
         [mem-bits (ram-read address ram)]
         [acc-val (sign-mag->int acc-bits)]
         [mem-val (sign-mag->int mem-bits)]
         [result-val (- acc-val mem-val)])
    (if (fits-sign-mag? result-val)
        ; Result fits - set acc to result, aeb to 0
        (let* ([new-acc-bits (int->sign-mag result-val)]
               [new-cpu (set-register (set-register cpu 'acc new-acc-bits) 'aeb '(0))])
          (conf new-cpu ram))
        ; Overflow - set acc to +0, aeb to 1
        (let* ([new-cpu (set-register (set-register cpu 'acc '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)) 'aeb '(1))])
          (conf new-cpu ram)))))
